#############################################
# Kincony A2S GPIO Definition
#############################################
# GPIO15	Relay1
# GPIO2	  Relay2
# GPIO33	1-wire GPIO-1
# GPIO14	1-wire GPIO-2
# GPIO35	RS485-RXD
# GPIO32	RS485-TXD
# GPIO34	GSM-RXD
# GPIO13	GSM-TXD
#############################################

# Include external package
packages:
  dds661_wattmeter: !include packages/a2s-vodarna/wattmeter-dds661.yaml
  a2s_main: !include packages/a2s-vodarna/a2s-main.yaml


esphome:
  name: a2s-vodarna
  friendly_name: a2s-vodarna
  on_boot:
    priority: -100
    then:
      - lambda: |-
          // Obnovení adresy controlleru z global
          auto saved_addr = id(controller_current_address);
          if (saved_addr >= 1 && saved_addr <= 247) {
            id(wattmeter_cerpadlo)->set_address(saved_addr);
            char msg[50];
            sprintf(msg, "Controller address restored to %d", saved_addr);
            ESP_LOGI("DDS661", msg);
          }

esp32:
  board: esp32dev
  framework:
    type: esp-idf

logger:
  logs:
    modbus_controller: debug

api:
ota:
  - platform: esphome

ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk_mode: GPIO17_OUT
  phy_addr: 0

i2c:
- id: bus_a
  sda: GPIO4
  scl: GPIO5
  scan: true

time:
- platform: homeassistant
  id: homeassistant_time

uart:
  id: mod_bus
  rx_pin: GPIO13 
  tx_pin: GPIO32
  baud_rate: 9600
  stop_bits: 1
  parity: EVEN

modbus:
  send_wait_time: 200ms
  id: rs485


################# Periodické úkoly pro DDS661
interval:
  # První interval - nastaví adresu a pošle příkaz
  - interval: 3s
    then:
      - lambda: |-
          // Long scan logika - nastavení adresy
          if (!id(long_scan_running)) return;
          
          auto current_addr = id(long_scan_current_addr);
          
          // Nastav adresu controlleru
          id(wattmeter_cerpadlo)->set_address(current_addr);
          
          // Kontrola, jestli už není scan zastaven PO nastavení adresy
          if (!id(long_scan_running)) return;
          
          // Vyvolej cteni napeti na aktualni adrese (async)
          auto voltage_cmd = esphome::modbus_controller::ModbusCommandItem::create_read_command(
            id(wattmeter_cerpadlo), esphome::modbus_controller::ModbusRegisterType::READ, 0x0000, 2);
          id(wattmeter_cerpadlo)->queue_command(voltage_cmd);
          
          char status[100];
          sprintf(status, "Scanning address %d...", current_addr);
          id(dds661_long_scan_state).publish_state(status);
          
          char addr_str[10];
          sprintf(addr_str, "%d", current_addr);
          id(dds661_last_scan_address).publish_state(addr_str);
          
          ESP_LOGI("MODBUS_SCANNER", "Starting scan of address %d", current_addr);

  # Druhý interval - vyhodnotí výsledky
  - interval: 4s
    then:
      - lambda: |-
          if (!id(long_scan_running)) return;
          
          auto current_addr = id(long_scan_current_addr);
          auto voltage = id(dds661_voltage).state;
          
          ESP_LOGI("MODBUS_SCANNER", "Address %d evaluation: voltage = %.2f", current_addr, voltage);
          
          // Kontrola, jestli jsou data validní a realistická
          if (!isnan(voltage) && voltage > 200.0f && voltage < 260.0f) {
              // Našli jsme zařízení - ale počkej ještě jeden cyklus pro potvrzení
              if (id(long_scan_found_addr) == current_addr) {
                  // Druhé potvrzení - skutečně jsme našli zařízení
                  id(long_scan_running) = false;
                  id(wattmeter_cerpadlo)->set_address(current_addr);
                  id(controller_current_address) = current_addr;
                  
                  char found_msg[100];
                  sprintf(found_msg, "Device confirmed at address %d! (voltage: %.1fV)", current_addr, voltage);
                  id(dds661_long_scan_state).publish_state(found_msg);
                  ESP_LOGI("DDS661", "Device confirmed at address %d", current_addr);
                  return;
              } else {
                  // První nález validních dat - ulož pro potvrzení
                  id(long_scan_found_addr) = current_addr;
                  ESP_LOGI("MODBUS_SCANNER", "Potential device at address %d, waiting for confirmation", current_addr);
                  return; // Počkej na potvrzení v dalším cyklu
              }
          } else {
              // Žádná validní data
              id(long_scan_found_addr) = 0; // Reset nálezu
          }
          
          // Pokračuj na další adresu pouze pokud scan stále běží
          if (id(long_scan_running)) {
              if (current_addr < 247) {
                  id(long_scan_current_addr) = current_addr + 1;
                  ESP_LOGI("MODBUS_SCANNER", "Moving to next address: %d", current_addr + 1);
              } else {
                  // Scan dokončen
                  id(long_scan_running) = false;
                  id(dds661_long_scan_state).publish_state("Long scan completed - no device found");
                  ESP_LOGI("DDS661", "Long scan completed - no device found");
              }
          }





